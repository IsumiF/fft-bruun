# Bruun's FFT

---

## 算法描述

设输入序列为$x_n$，对应的傅里叶变换为$X_n$
$$
\begin{aligned}
x(z) &= \sum_{n=0}^{N-1} x_n z^n \\
\omega_N^n &= e^{\frac{-2\pi i}{N}n}\\
X_k &= x(z)\;\mathrm{mod}\; (z - w_N^k)
\end{aligned}
$$
$\omega_N^n$称为 complex root of unity
求傅里叶变换，等价于求多项式$x(z)$依次模$z-w_N^k$\
先假定，下面提到的多项式模运算复杂度均是关于被除式线性，后面再详述。\
如果直接求$x(z)$模每个$z-\omega_N^k$，总体的复杂度就是$O(N^2)$，和直接按定义计算没有区别了。但是，模运算有这样一个性质：
$$
x(z)\;\mathrm{mod}\; U(z)= (x(z)\;\mathrm{mod}\;U(z)V(z)) \;\mathrm{mod}\; U(z)
$$
也就是说，我们先模两个多项式的乘积，再模组成这个乘积的一个多项式，和直接模这个多项式结果是一样的。

注意到一个事实：
$$
\Pi(z-\omega_N^k) = z^N-1
$$

我们只要对$z^N -1$不断做因式分解，最终就能分解到每个$z-\omega_N^k$，并且，在分解过程中，计算$x(z)$模这些中间因式的结果（不直接算，而是通过上一层模的结果再模下一层得到），最终算出$x(z)$模每个$z-\omega_N^k$的结果。\
这里的因式分解只有三种情况：
$$
\begin{aligned}
& z^{2M} - 1= (z^M-1)(z^M +1) \\
& z^{4M} + az^{2M} + 1 = (z^{2M} + \sqrt{2-a}z^M + 1)(z^{2M} - \sqrt{2-a}z^M + 1) \\
& z^{2} + az + 1 = (z - \frac{a + \sqrt{a^2 - 4}}{2})(z - \frac{a - \sqrt{a^2 - 4}}{2})
\end{aligned}
$$
首先注意到一点，如果输入数据全部是实数，该算法只有到最后一步（复杂度$O(n)$，低于总体复杂度$O(n\log n$）分解二次式时才可能出现复数，所以过程中绝大部分计算都是在实数域进行的。

因式分解到最后一层之后，得到输入各项傅里叶变换的值，但是顺序被打乱了。由于那些一次多项式的常数项和complex roots of unity在数值上是对应的，可以先把它们各自四舍五入到某一精度，比如小数点后6位，然后对输入数据的每个下标，用它的complex roots of unity在一个从最后一层的多项式的常数项到傅里叶变换值的Map中查询。如果这个Map使用树实现，则$N$次查询复杂度为$O(N\log N)$。

下面来分析一下“因式分解时计算模”的复杂度。\
输入数据长度为$N$，$N$为2的整指数幂，则$z^N - 1$经过$\log N$层因式分解后变为若干一次式的乘积，并同时得到傅里叶变换的值（顺序被打乱）\
这$\log N$层计算的每一层因式分解的数量分别为：
$$
2^0, 2^1, 2^2,\dots ,2^{\log N}
$$
每一层单次模运算的复杂度为
$$
N,\frac{N}{2},\frac{N}{2^2}\dots ,1
$$
把这些对应项乘起来再相加，就得到$N \log N$，即这一部分的复杂度为$O(N \log N)$

现在来说明一个$O(n)$复杂度的模运算（被除式长度$n$）的实现。\
我们用一个数组来表示被除式，里面的值代表多项式的系数，下标越小代表的次数越高，数组长度减一就是多项式的次数。从前面的三种情况下的因式分解中看到，除式的特点是，系数非0的项数目有限，最多3项。于是用二元组的列表来表示除式，每一个二元组中记录该项的次数和系数。\
Wikipedia 的 [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division) 给出了多项式长除的伪代码：
```
function n / d:
  require d ≠ 0
  r ← n
  while r ≠ 0 AND degree(r) ≥ degree(d):
     t ← lead(r)/lead(d)     # Divide the leading terms
     r ← r − t * d
  return (q, r)
```
我们关心的是，这个伪代码能不能在$O(n)$复杂度实现。\
首先，循环次数不超过`r`原本的次数，因为每循环一次`r`的次数至少降低1。\
存储一个Bool类型的变量`rIsZero`，表示`r`是否为0，每次循环体去更新它，这样`r ≠ 0`的复杂度就是$O(1)$，同时类似地存储`r`的次数`rDeg`。\
循环体内，`lead(r) / lead(d)` 复杂度为$O(1)$\
`t`只有一项，`d`采用二元组的列表表示，由于这个列表长度不超过3，所以`t * d`复杂度为$O(1)$\
`r - t * d`这一步，减法本身复杂度也是$O(1)$，和上面同理。接下来要更新`rIsZero`。根据`rDeg`找到`r`的最高次项的下标，从这个项开始，向较低次项线性查找，直到遇到第一个不为0的数，那么这个数就是新的最高次项。根据它的位置来更新`rDeg`。如果找不到，就把`rIsZero`置`True`。这一步看起来是个线性操作，但是整个`while`循环结束之后，这个线性查找遍历过的项的总数不会超过$n$，所以它对总体贡献的复杂度还是$O(n)$，不需要乘以循环的复杂度。

